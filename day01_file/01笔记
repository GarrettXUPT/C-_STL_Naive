函数模板与普通函数的区别：
    1、函数模板不允许自动类型转换，函数模板必须严格的进行匹配 
    2、普通函数可以进行自动类型转换

函数模板与普通函数调用的规则：
    1、函数模板可以像普通函数一样被重载
    2、C++编译器优先考虑普通函数，当普通函数与模板函数相同时；只有当普通函数不满足时候，才会调用模板函数
    
C/C++编译流程：
     1、预编译 index.cpp --> index.i
     2、将预编译文件传输给编译器，生成汇编文件index.s
     3、将汇编文件传入到汇编器，生成目标文件index.obj
     4、将目标文件传入到链接器生成可执行文件index.exe

编译原理：
    函数模板
    template<class T>
    void MySwap(T &a, T &b, T &c){
        return;
    }
    由模板函数根据使用时传入的类型，生成具体的函数，即为模板函数
    函数模板机制结论：
        1、编译器不是吧函数模板处理成能够处理任何类型的函数
        2、函数模板通过不同的类型，生成不同的函数
        3、编译器会对函数模板进行两次编译，在生命的地方对魔板代码本身进行编译，在调用的地方对参数替换后的代码进行编译

类模板中的static关键字：
    在类模板创建具体的类时，相同模板类型person<int>会创建一个该类下独有的static，若还有person<char>，则
    有会创建另一个static，在类模板中尽量不要使用友元

类型转换：
    static_cast 静态类型转换，作用于基本数据类型，还有具有继承关系的指针和引用
    dynamic_cast 动态类型转换，转换具有继承关系的指针或者引用，在转换前会进行对象类型的检查，只允许父类转子类
    const_cast 主要针对const的转换,取消const作用，针对指针和引用，或者对象指针，可以增加或者解除const
    reinterpret_cast 进行没有任何关联之间的转换，比如一个字符转换为一个整数 任何类型的值都可以转化为其他类型的值，也就是强制类型转换
    结论：
        1、在使用时，必须要清楚转换前，转换后的类型，并且要明白后果
        2、一般不建议类型转换，尽量避免类型转换

异常对象的生命周期：
    
    



